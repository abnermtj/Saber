#include <stdint.h>
#include <avr/interrupt.h>
#include <avr/io.h>
#include <avr/pgmspace.h>

#define SAMPLE_RATE 8000
#define SPEAKER_PIN 11
// audio properties
int snd_buzz_speed = 47;
int snd_hum1_speed = 50;
int snd_hum2_speed = 52;

byte snd_buzz_volume = 0;
byte snd_hum1_volume = 0;
byte snd_hum2_volume = 0;

// sound fonts
#define BUZZ_WAVE_LENGTH 205
byte buzz_wave[BUZZ_WAVE_LENGTH] = {
  0x82, 0x82, 0x75, 0x65, 0x55, 0x4B, 0x5E, 0x74, 0x7C, 0x71, 0x57, 0x58,
  0x89, 0xAE, 0xB3, 0xC8, 0xD4, 0xBD, 0x83, 0x4B, 0x34, 0x42, 0x6D, 0x9F,
  0xD6, 0xF7, 0xF5, 0xD6, 0xB5, 0xA8, 0x9B, 0x8B, 0x77, 0x57, 0x31, 0x19,
  0x1B, 0x29, 0x3C, 0x64, 0x99, 0xBE, 0xBA, 0x9F, 0x87, 0x76, 0x6B, 0x66,
  0x67, 0x6E, 0x7E, 0x95, 0x9E, 0x8E, 0x75, 0x5C, 0x57, 0x5D, 0x5F, 0x63,
  0x62, 0x61, 0x5B, 0x56, 0x57, 0x56, 0x64, 0x82, 0x9F, 0xB8, 0xCF, 0xE0,
  0xE2, 0xD9, 0xC3, 0x9D, 0x84, 0x7D, 0x7A, 0x7A, 0x7B, 0x85, 0x90, 0x98,
  0x8E, 0x72, 0x61, 0x5C, 0x6A, 0x81, 0x94, 0x9D, 0x9F, 0x94, 0x7A, 0x5E,
  0x48, 0x3D, 0x38, 0x3E, 0x4A, 0x5D, 0x74, 0x80, 0x85, 0x82, 0x7C, 0x77,
  0x73, 0x76, 0x7D, 0x96, 0xB4, 0xC5, 0xC5, 0xBE, 0xB5, 0xA6, 0x93, 0x82,
  0x6E, 0x5A, 0x56, 0x59, 0x5C, 0x60, 0x66, 0x69, 0x6D, 0x6F, 0x69, 0x6C,
  0x78, 0x88, 0x93, 0xA1, 0xA7, 0xA4, 0xA0, 0x9D, 0x9E, 0x9E, 0x99, 0x8D,
  0x83, 0x7D, 0x73, 0x6D, 0x74, 0x7F, 0x80, 0x78, 0x6A, 0x57, 0x45, 0x37,
  0x36, 0x47, 0x64, 0x7A, 0x8B, 0x93, 0x8E, 0x8B, 0x8E, 0x99, 0xA8, 0xB5,
  0xBE, 0xC5, 0xC7, 0xBC, 0xA8, 0x98, 0x8E, 0x8B, 0x87, 0x7F, 0x79, 0x7F,
  0x80, 0x80, 0x7E, 0x72, 0x68, 0x5E, 0x59, 0x5C, 0x5C, 0x64, 0x6F, 0x7D,
  0x80, 0x76, 0x6B, 0x62, 0x69, 0x74, 0x7F, 0x8A, 0x92, 0x95, 0x90, 0x86,
  0x7B
};

#define HUM1_WAVE_LENGTH 133
byte hum1_wave[HUM1_WAVE_LENGTH] = {
  0x7F, 0x73, 0x65, 0x56, 0x4C, 0x49, 0x4B, 0x53, 0x60, 0x6F, 0x7C, 0x8B,
  0x98, 0xA4, 0xB0, 0xBA, 0xC6, 0xCA, 0xC0, 0xAF, 0x93, 0x71, 0x52, 0x38,
  0x26, 0x1E, 0x1D, 0x26, 0x32, 0x45, 0x5C, 0x73, 0x89, 0x98, 0xA2, 0xA9,
  0xAD, 0xA8, 0x9E, 0x92, 0x83, 0x78, 0x72, 0x6C, 0x6B, 0x71, 0x79, 0x82,
  0x8D, 0x96, 0x98, 0x94, 0x92, 0x93, 0x94, 0x99, 0xA0, 0xA7, 0xA8, 0xA5,
  0xA3, 0x9F, 0x98, 0x92, 0x8F, 0x88, 0x83, 0x7A, 0x6C, 0x5E, 0x50, 0x47,
  0x43, 0x44, 0x50, 0x61, 0x71, 0x83, 0x97, 0xA6, 0xB5, 0xC1, 0xCC, 0xD1,
  0xC8, 0xBA, 0xA0, 0x7E, 0x5E, 0x41, 0x2C, 0x1D, 0x17, 0x1B, 0x24, 0x34,
  0x4A, 0x63, 0x79, 0x8C, 0x9A, 0xA1, 0xA7, 0xA5, 0x9C, 0x90, 0x81, 0x76,
  0x6E, 0x68, 0x66, 0x6A, 0x72, 0x7A, 0x83, 0x8B, 0x8D, 0x89, 0x86, 0x87,
  0x88, 0x8E, 0x99, 0xA1, 0xA6, 0xA6, 0xA6, 0xA3, 0x9C, 0x98, 0x99, 0x96,
  0x91
};

#define HUM2_WAVE_LENGTH 133
byte hum2_wave[HUM2_WAVE_LENGTH] = {
  0x7A, 0x73, 0x6E, 0x62, 0x5D, 0x5F, 0x63, 0x70, 0x7B, 0x85, 0x93, 0x9E,
  0xAB, 0xB4, 0xC1, 0xC9, 0xCC, 0xCA, 0xC0, 0xB9, 0xB3, 0xAC, 0xAA, 0xA3,
  0xA0, 0xA1, 0x98, 0x91, 0x87, 0x76, 0x65, 0x53, 0x45, 0x37, 0x34, 0x2E,
  0x22, 0x25, 0x28, 0x2F, 0x3C, 0x48, 0x53, 0x60, 0x74, 0x7C, 0x8A, 0x95,
  0x99, 0xA4, 0xA2, 0x9F, 0x9A, 0x95, 0x90, 0x8B, 0x8D, 0x8D, 0x8F, 0x90,
  0x93, 0x96, 0x97, 0x97, 0x92, 0x8B, 0x86, 0x78, 0x64, 0x5A, 0x4E, 0x48,
  0x4A, 0x4D, 0x55, 0x5D, 0x6F, 0x85, 0x97, 0xAB, 0xBA, 0xC7, 0xCA, 0xCA,
  0xC9, 0xBC, 0xB6, 0xAE, 0xA2, 0x9E, 0x9E, 0x9D, 0x97, 0x92, 0x89, 0x78,
  0x6A, 0x55, 0x49, 0x41, 0x37, 0x36, 0x34, 0x33, 0x3D, 0x45, 0x50, 0x61,
  0x72, 0x82, 0x8F, 0x99, 0x9C, 0xA2, 0xA1, 0x98, 0x90, 0x88, 0x7F, 0x76,
  0x77, 0x76, 0x7B, 0x87, 0x82, 0x81, 0x7C, 0x7A, 0x87, 0x91, 0x9C, 0x99,
  0x8D
};


// inline byte sound_sample(int* index, byte* wave, int wave_speed, byte wave_length) {
//   // interpolate next sample
//   int i = *index;
//   // /* DEBUG*/

//   //   i += wave_speed;
//   //   i = i % wave_length;
//   // return wave[i];

//   byte si1 = (i >> 8);  // first sample index
//   byte si2 = (si1 + 1) % wave_length;

//   int sj1 = i & 255;    // sample sub-index
//   int sj2 = 256 - sj1;  //

//   // mix the two sample values
//   unsigned int s1 = wave[si1];
//   s1 *= sj2;
//   unsigned int s2 = wave[si2];
//   s2 *= sj1;
//   unsigned int sample = s1 + s2;

//   // increment index, wrap at limit
//   i += wave_speed;
//   unsigned int index_limit = wave_length << 8;
//   if (i >= index_limit) i -= index_limit;
//   *index = i;

//   // return the top byte
//   return sample / 256;
// }

// sound generators
volatile uint16_t snd_index_1 = 0;
volatile uint16_t snd_index_2 = 0;
volatile uint16_t snd_index_3 = 0;

volatile uint16_t sample;
byte lastSample;
int sounddata_length = HUM2_WAVE_LENGTH;

void stopPlayback()
{
  // Disable playback per-sample interrupt.
  TIMSK1 &= ~_BV(OCIE1A);

  // Disable the per-sample timer completely.
  TCCR1B &= ~_BV(CS10);

  // Disable the PWM timer.
  TCCR2B &= ~_BV(CS10);

  digitalWrite(SPEAKER_PIN, LOW);
}

ISR(TIMER1_COMPA_vect)
{
  if (sample >= sounddata_length)
  {
    if (sample == sounddata_length + lastSample)
    {
      stopPlayback();
    }
    else
    {
      // Ramp down to zero to reduce the click at the end of playback.
      OCR2A = sounddata_length + lastSample - sample;
    }
  }
  else
  {
    OCR2A = pgm_read_byte(&hum2_wave[sample]);
  }

  ++sample;
}

// // If OCR0A = 255 then this ISR runs at  ~60 KHz
// ISR(TIMER1_COMPA_vect) {
//   // combine the wave and global volume into channel volumes
//   unsigned int v1 = snd_buzz_volume;
//   v1 *= 256;  //v1 = v1 >> 8;
//   unsigned int v2 = snd_hum1_volume;
//   v2 *= 256;  //v2 = v2 >> 8;
//   unsigned int v3 = snd_hum2_volume;
//   v3 *= 256;  //v3 = v3 >> 8;
//   // sample our primary waveforms, and multiply by their master volumes
//   int s1 = (sound_sample(&snd_index_1, buzz_wave, snd_buzz_speed, BUZZ_WAVE_LENGTH) - 128) * v1;
//   int s2 = (sound_sample(&snd_index_2, hum1_wave, snd_hum1_speed, HUM1_WAVE_LENGTH) - 128) * v2;
//   int s3 = (sound_sample(&snd_index_3, hum2_wave, snd_hum2_speed, HUM2_WAVE_LENGTH) - 128) * v3;

//   unsigned int sample = 0x8000 + s1 + s2 + s3;
// #ifdef AUDIO_9BIT
//   OCR0B = (sample >> 7) & 0x1ff;
// #endif
// #ifdef AUDIO_8BIT
//   OCR0B = (sample >> 9) & 0xff;
// #endif
// #ifdef AUDIO_7BIT
//   OCR0B = (sample >> 9) & 0x7f;
// #endif
// #ifdef AUDIO_6BIT
//   OCR0B = (sample >> 10) & 0x3f;
// #endif
// #ifdef AUDIO_4BIT
//   OCR0B = (sample >> 12) & 0x0f;
// #endif
// }

// Atmega328P
// Timer/counter 0 - 8 bit (255)
// Timer/counter 1 - 16 bit (65,535)
// Timer/counter 2 - 8 bit (255)
void snd_init() {
  pinMode(SPEAKER_PIN, OUTPUT);

// Set up Timer 2 to do pulse width modulation on the speaker
  // pin.

  // Use internal clock (datasheet p.213)
  ASSR &= ~(_BV(EXCLK) | _BV(AS2));

  // Set fast PWM mode  (p.157)
  TCCR2A |= _BV(WGM21) | _BV(WGM20);
  TCCR2B &= ~_BV(WGM22);

  // Do non-inverting PWM on pin OC2A (p.155)
  // On the Arduino this is pin 11.
  TCCR2A = (TCCR2A | _BV(COM2A1)) & ~_BV(COM2A0);
  TCCR2A &= ~(_BV(COM2B1) | _BV(COM2B0));

  // No prescaler (p.158)
  TCCR2B = (TCCR2B & ~(_BV(CS12) | _BV(CS11))) | _BV(CS10);

  // Set initial pulse width to the first sample.
  OCR2A = pgm_read_byte(&hum2_wave[0]);
  
  // Set up Timer 0 to do pulse width modulation on the speaker
  // pin.

  // Use internal clock (datasheet p.160)
  ASSR &= (0 << EXCLK) | (1 << AS2);

  // setup timer0 (pin 5 or 6):
  TCNT0 = 0;

  // Timer/Counter4 fast PWM mode (WGM22) where TOP = 0xFF
  TCCR0A |= _BV(WGM01) | _BV(WGM00);
  TCCR0B &= ~_BV(WGM02);

  // Do non-inverting PWM on pin OC2A (p.155)
  // Clear OC0B on Compare Match, set OC0B at BOTTOM
  // On the Arduino this is pin 11.
  TCCR0A = (TCCR0A | _BV(COM0A1)) & ~_BV(COM0A0);
  TCCR0A &= ~(_BV(COM0B1) | _BV(COM0B0));

  // No prescaler (p.158)
  TCCR0B = (TCCR0B & ~(_BV(CS02) | _BV(CS01))) | _BV(CS00);

  OCR2A = pgm_read_byte(hum2_wave[0]);


  // Set up Timer 1 to send a sample every interrupt.

  cli();

  // Set CTC mode (Clear Timer on Compare Match) (p.133)
  // Have to set OCR1A *after*, otherwise it gets reset to 0!
  TCCR1B = (TCCR1B & ~_BV(WGM12));
  TCCR1A = TCCR1A | _BV(WGM11) & ~_BV(WGM10);

  // No prescaler (pg172)
  TCCR1B = (TCCR1B & ~(_BV(CS12) | _BV(CS11))) | _BV(CS10);

  // Set the compare register (OCR1A).
  // OCR1A is a 16-bit register, so we have to do this with
  // interrupts disabled to be safe.
  OCR1A = F_CPU / SAMPLE_RATE;  // 16e6 / 8000 = 2000

  // Enable interrupt when TCNT1 == OCR1A (p.184) This calls ISR
  TIMSK1 |= _BV(OCIE1A);

  lastSample = pgm_read_byte(&hum2_wave[HUM2_WAVE_LENGTH- 1]);
  sample = 0;
  sei();
}